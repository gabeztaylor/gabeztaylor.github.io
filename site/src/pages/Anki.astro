---
import BaseLayout from "../layouts/BaseLayout.astro";
import { countStates, groupCardsByDeck, loadAnkiMasterDeck } from "../lib/ankiContent.js";

const loaded = loadAnkiMasterDeck();
const data = loaded.ok ? loaded.data : null;
const cards = Array.isArray(data?.cards) ? data.cards : [];
const decks = groupCardsByDeck(cards);
const totalCounts = countStates(cards);
const exportVersion = Number(data?.version) || 1;
const generatedAt = String(data?.generatedAt || "").trim();

const stateOrder = ["New", "Learning", "Review", "Relearning", "Unknown"];
function stateLabel(s) {
  return stateOrder.includes(s) ? s : "Unknown";
}

function formatIntervalDays(days) {
  const d = Math.max(0, Math.round(Number(days) || 0));
  if (d === 0) return "0d";
  if (d < 14) return `${d}d`;
  if (d < 60) return `${Math.round(d / 7)}w`;
  if (d < 365) return `${Math.round(d / 30)}mo`;
  return `${Math.round(d / 365)}y`;
}

const hasCardStats = cards.some((c) =>
  Number.isFinite(Number(c?.reviews)) || Number.isFinite(Number(c?.intervalDays)) || Number.isFinite(Number(c?.lapses)),
);
const hasSurfacedStats = cards.some((c) => Boolean(String(c?.lastSeenAt || "").trim()));

function formatShortDate(iso) {
  const s = String(iso || "").trim();
  const dt = new Date(s);
  if (!s || Number.isNaN(dt.getTime())) return "";
  return new Intl.DateTimeFormat("en-US", { month: "short", day: "numeric" }).format(dt);
}

const struggled = cards
  .filter((c) => Number(c?.reviews) > 0)
  .slice()
  .sort((a, b) => {
    const ar = Number(a?.reviews) || 0;
    const br = Number(b?.reviews) || 0;
    if (br !== ar) return br - ar;
    const al = Number(a?.lapses) || 0;
    const bl = Number(b?.lapses) || 0;
    if (bl !== al) return bl - al;
    return String(a?.deckName || "").localeCompare(String(b?.deckName || ""));
  })
  .slice(0, 8);

const mastered = cards
  .filter((c) => String(c?.state || "") === "Review")
  .slice()
  .sort((a, b) => {
    const ai = Number(a?.intervalDays) || 0;
    const bi = Number(b?.intervalDays) || 0;
    if (bi !== ai) return bi - ai;
    const al = Number(a?.lapses) || 0;
    const bl = Number(b?.lapses) || 0;
    if (al !== bl) return al - bl;
    const ar = Number(a?.reviews) || 0;
    const br = Number(b?.reviews) || 0;
    return ar - br;
  })
  .slice(0, 8);

const justSurfaced = cards
  .filter((c) => {
    const r = Number(c?.reviews) || 0;
    return r > 0 && r <= 4 && String(c?.lastSeenAt || "").trim();
  })
  .slice()
  .sort((a, b) => {
    const t = String(b?.lastSeenAt || "").localeCompare(String(a?.lastSeenAt || ""));
    if (t !== 0) return t;
    const ar = Number(a?.reviews) || 0;
    const br = Number(b?.reviews) || 0;
    if (ar !== br) return ar - br; // prefer fewer reviews when equally recent
    return String(a?.deckName || "").localeCompare(String(b?.deckName || ""));
  })
  .slice(0, 8);
---

<BaseLayout title="Anki">
  <section class="hero card">
    <div class="inner">
      <div class="kicker pill">Anki</div>
      <h1>Master Deck</h1>
      <p class="muted">Here is my growing Anki deck that I use to memorize ever more useless facts.</p>
      <div class="meta">
        <span class="pill">Cards: {cards.length}</span>
        <span class="pill">Export: v{exportVersion}</span>
        {stateOrder.map((s) => (
          <span class="pill">{s}: {totalCounts.get(s) || 0}</span>
        ))}
        {generatedAt && (
          <span class="pill" title={generatedAt}>Updated</span>
        )}
      </div>
    </div>
  </section>

  {!loaded.ok ? (
    <section class="card page">
      <div class="inner">
        <h2>Not synced yet</h2>
        <p class="muted">
          Export file not found at <code>{loaded.exportPath}</code>.
        </p>
        <p class="muted">
          Run the local exporter (Study Journal → “Sync Anki → Site”) to generate <code>docs/anki/master-deck.json</code>.
        </p>
      </div>
    </section>
  ) : (
    <section class="card page">
      <div class="inner">
        <div class="spotlights">
          <details class="spot card">
            <summary class="spotSummary">
              <div class="spotHead">
                <div class="spotTitleRow">
                  <h2>Just surfaced</h2>
                  {(hasCardStats || hasSurfacedStats) && <span class="pill tiny">{justSurfaced.length}</span>}
                </div>
                <div class="muted small">Recently introduced cards (low review count)</div>
              </div>
              <span class="chev" aria-hidden="true">▾</span>
            </summary>
            <div class="spotBody">
              {!hasSurfacedStats ? (
                <p class="muted small">
                  Sync Anki again to include “first seen” timestamps in the export.
                </p>
              ) : justSurfaced.length === 0 ? (
                <p class="muted small">No newly surfaced cards yet.</p>
              ) : (
                <div class="cards compact">
                  {justSurfaced.map((c) => (
                    <div
                      class="cardRow"
                      data-state={stateLabel(String(c.state || ""))}
                      data-text={String(c.frontText || "").toLowerCase()}
                    >
                      <span class="state">{stateLabel(String(c.state || ""))}</span>
                      <div class="qa">
                        <div class="metaLine muted small">
                          <span class="mono">{c.deckName}</span>
                          {c.lastSeenAt && (
                            <>
                              <span class="sep">·</span>
                              <span>seen <strong>{formatShortDate(c.lastSeenAt) || "recently"}</strong></span>
                              <span class="sep">·</span>
                              <span>{Number(c.reviews) || 0} reviews</span>
                            </>
                          )}
                        </div>
                        <div class="front" set:html={c.frontHtml || c.frontText || ""} />
                        {c.backHtml && (
                          <details class="answer">
                            <summary>Answer</summary>
                            <div class="back" set:html={c.backHtml} />
                          </details>
                        )}
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>
          </details>

          <details class="spot card">
            <summary class="spotSummary">
              <div class="spotHead">
                <div class="spotTitleRow">
                  <h2>Most reviewed</h2>
                  {hasCardStats && <span class="pill tiny">{struggled.length}</span>}
                </div>
                <div class="muted small">A sample of cards with the most total reviews</div>
              </div>
              <span class="chev" aria-hidden="true">▾</span>
            </summary>
            <div class="spotBody">
              {!hasCardStats ? (
                <p class="muted small">
                  Sync Anki again to include review statistics in the export.
                </p>
              ) : struggled.length === 0 ? (
                <p class="muted small">No reviewed cards yet.</p>
              ) : (
                <div class="cards compact">
                  {struggled.map((c) => (
                    <div
                      class="cardRow"
                      data-state={stateLabel(String(c.state || ""))}
                      data-text={String(c.frontText || "").toLowerCase()}
                    >
                      <span class="state">{stateLabel(String(c.state || ""))}</span>
                      <div class="qa">
                        <div class="metaLine muted small">
                          <span class="mono">{c.deckName}</span>
                          <span class="sep">·</span>
                          <span><strong>{Number(c.reviews) || 0}</strong> reviews</span>
                          {Number(c.lapses) ? (
                            <>
                              <span class="sep">·</span>
                              <span>{Number(c.lapses) || 0} lapses</span>
                            </>
                          ) : null}
                        </div>
                        <div class="front" set:html={c.frontHtml || c.frontText || ""} />
                        {c.backHtml && (
                          <details class="answer">
                            <summary>Answer</summary>
                            <div class="back" set:html={c.backHtml} />
                          </details>
                        )}
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>
          </details>

          <details class="spot card">
            <summary class="spotSummary">
              <div class="spotHead">
                <div class="spotTitleRow">
                  <h2>Mastered</h2>
                  {hasCardStats && <span class="pill tiny">{mastered.length}</span>}
                </div>
                <div class="muted small">Long-interval cards (reviewed less frequently)</div>
              </div>
              <span class="chev" aria-hidden="true">▾</span>
            </summary>
            <div class="spotBody">
              {!hasCardStats ? (
                <p class="muted small">
                  Sync Anki again to include interval statistics in the export.
                </p>
              ) : mastered.length === 0 ? (
                <p class="muted small">No mature review cards yet.</p>
              ) : (
                <div class="cards compact">
                  {mastered.map((c) => (
                    <div
                      class="cardRow"
                      data-state={stateLabel(String(c.state || ""))}
                      data-text={String(c.frontText || "").toLowerCase()}
                    >
                      <span class="state">{stateLabel(String(c.state || ""))}</span>
                      <div class="qa">
                        <div class="metaLine muted small">
                          <span class="mono">{c.deckName}</span>
                          <span class="sep">·</span>
                          <span><strong>{formatIntervalDays(c.intervalDays)}</strong> interval</span>
                          {Number(c.reviews) ? (
                            <>
                              <span class="sep">·</span>
                              <span>{Number(c.reviews) || 0} reviews</span>
                            </>
                          ) : null}
                          {Number(c.lapses) ? (
                            <>
                              <span class="sep">·</span>
                              <span>{Number(c.lapses) || 0} lapses</span>
                            </>
                          ) : null}
                        </div>
                        <div class="front" set:html={c.frontHtml || c.frontText || ""} />
                        {c.backHtml && (
                          <details class="answer">
                            <summary>Answer</summary>
                            <div class="back" set:html={c.backHtml} />
                          </details>
                        )}
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>
          </details>
        </div>

        <div class="toolbar">
          <input id="ankiSearch" class="pill" type="search" placeholder="Search cards…" />
          <div class="filters" id="ankiFilters">
            <button class="chip active" type="button" data-state="ALL">All</button>
            {stateOrder.map((s) => (
              <button class="chip" type="button" data-state={s}>{s}</button>
            ))}
          </div>
        </div>

        <div class="deckList" id="ankiDeckList">
          {decks.map((d) => {
            const counts = countStates(d.cards);
            return (
              <details class="deck">
                <summary>
                  <div class="left">
                    <div class="name" title={d.deckName}>{d.displayName || d.deckName}</div>
                    <div class="muted small">{d.cards.length} cards</div>
                  </div>
                  <div class="right">
                    {stateOrder.map((s) => (
                      <span class="badge">{s}: {counts.get(s) || 0}</span>
                    ))}
                  </div>
                </summary>
                <div class="cards">
                  {d.cards.map((c) => (
                    <div class="cardRow" data-state={stateLabel(String(c.state || ""))} data-text={String(c.frontText || "").toLowerCase()}>
                      <span class="state">{stateLabel(String(c.state || ""))}</span>
                      <div class="qa">
                        <div class="front" set:html={c.frontHtml || c.frontText || ""} />
                        {c.backHtml && (
                          <details class="answer">
                            <summary>Answer</summary>
                            <div class="back" set:html={c.backHtml} />
                          </details>
                        )}
                      </div>
                    </div>
                  ))}
                </div>
              </details>
            );
          })}
        </div>
      </div>
    </section>
  )}
</BaseLayout>

<style>
  .hero { padding: 18px; }
  .hero .inner { display: grid; gap: 12px; padding: 12px; }
  .kicker { width: fit-content; font-weight: 800; font-size: 12px; color: var(--muted); }
  .meta { display: flex; flex-wrap: wrap; gap: 8px; }

  .page { padding: 18px; }
  .page .inner { padding: 12px; }

  .spotlights {
    display: grid;
    gap: 12px;
    margin-bottom: 14px;
  }
  .spot { padding: 0; overflow: hidden; }
  .spotSummary {
    list-style: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
    padding: 12px;
  }
  .spotSummary::-webkit-details-marker { display: none; }
  .spotBody { padding: 0 12px 12px; }
  .spotHead { display: grid; gap: 4px; }
  .spotTitleRow { display: inline-flex; align-items: baseline; gap: 8px; }
  .spotHead h2 { margin: 0; font-size: 16px; }
  .chev { color: var(--muted); font-weight: 900; transform: rotate(0deg); transition: transform 160ms ease; }
  details.spot[open] .chev { transform: rotate(180deg); }

  .pill.tiny { font-size: 11px; padding: 4px 8px; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  .metaLine { display: flex; flex-wrap: wrap; gap: 8px; align-items: baseline; margin-bottom: 8px; }
  .sep { opacity: 0.6; }
  .cards.compact { padding: 0; }
  .cards.compact .cardRow { background: color-mix(in oklab, var(--surface2) 55%, transparent); }

  @media (min-width: 860px) {
    .spotlights { grid-template-columns: 1fr 1fr; }
  }

  .toolbar { display: grid; gap: 10px; margin-bottom: 14px; }
  .filters { display: flex; flex-wrap: wrap; gap: 8px; }
  .chip {
    border: 1px solid var(--border);
    background: var(--surface);
    color: var(--muted);
    font-weight: 850;
    font-size: 12px;
    padding: 7px 10px;
    border-radius: 999px;
    cursor: pointer;
  }
  .chip.active {
    color: var(--text);
    border-color: color-mix(in oklab, var(--accent) 35%, var(--border));
  }

  .deck { border: 1px solid var(--border); border-radius: 14px; background: var(--surface); margin: 12px 0; }
  .deck summary {
    list-style: none;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    gap: 12px;
    padding: 12px 12px;
    font-weight: 900;
  }
  .deck summary::-webkit-details-marker { display: none; }
  .name { font-size: 14px; }
  .small { font-size: 12px; }
  .right { display: inline-flex; gap: 8px; flex-wrap: wrap; justify-content: flex-end; }
  .badge {
    font-size: 11px;
    color: var(--muted);
    border: 1px solid var(--border);
    background: var(--surface2);
    padding: 4px 8px;
    border-radius: 999px;
    white-space: nowrap;
    font-weight: 850;
  }

  .cards { padding: 0 12px 12px; display: grid; gap: 8px; }
  .cardRow {
    display: grid;
    grid-template-columns: 92px minmax(0, 1fr);
    gap: 10px;
    padding: 10px 10px;
    border-radius: 12px;
    border: 1px solid var(--border);
    background: color-mix(in oklab, var(--surface2) 65%, transparent);
    align-items: start;
    overflow: hidden;
  }
  .state {
    font-size: 12px;
    font-weight: 900;
    color: var(--muted);
    border: 1px solid var(--border);
    background: var(--surface);
    padding: 6px 8px;
    border-radius: 999px;
    width: fit-content;
  }
  .qa { min-width: 0; }
  .front :global(*) { margin: 0; }
  .front { line-height: 1.45; min-width: 0; overflow: hidden; }
  .front :global(img) {
    max-width: 100% !important;
    max-height: 220px !important;
    width: auto !important;
    height: auto !important;
    object-fit: contain;
    display: block;
    border-radius: 12px;
    border: 1px solid var(--border);
    background: var(--surface);
  }
  .front :global(picture),
  .front :global(svg) { max-width: 100%; height: auto; display: block; }

  .answer {
    margin-top: 10px;
    border: 1px solid var(--border);
    border-radius: 12px;
    background: var(--surface);
    padding: 8px 10px;
  }
  .answer summary {
    cursor: pointer;
    font-weight: 900;
    color: var(--muted);
    list-style: none;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  .answer summary::-webkit-details-marker { display: none; }
  .back { margin-top: 10px; }
  .back :global(img) {
    max-width: 100% !important;
    max-height: 320px !important;
    width: auto !important;
    height: auto !important;
    object-fit: contain;
    display: block;
    border-radius: 12px;
    border: 1px solid var(--border);
    background: var(--surface);
  }
  .back :global(*) { margin: 0; }

  @media (max-width: 720px) {
    .cardRow { grid-template-columns: 1fr; }
  }
</style>

<script is:inline>
  const search = document.getElementById("ankiSearch");
  const deckList = document.getElementById("ankiDeckList");
  const filters = document.getElementById("ankiFilters");
  let activeState = "ALL";

  function stripTypeDirectives(root) {
    if (!root) return;
    const re = /\[\[\s*type:[^\]]+\]\]|\{\{\s*type:[^}]+\}\}/i;
    const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT);
    const toRemove = [];
    while (walker.nextNode()) {
      const n = walker.currentNode;
      if (!n?.nodeValue) continue;
      if (re.test(n.nodeValue)) {
        n.nodeValue = n.nodeValue.replace(re, "").trim();
        if (!n.nodeValue) toRemove.push(n);
      }
    }
    for (const n of toRemove) {
      try { n.parentNode?.removeChild(n); } catch {}
    }
  }

  function apply() {
    const q = String(search?.value || "").trim().toLowerCase();
    const rows = Array.from(deckList?.querySelectorAll?.(".cardRow") || []);
    for (const r of rows) {
      const s = r.getAttribute("data-state") || "";
      const text = r.getAttribute("data-text") || "";
      const okState = activeState === "ALL" || s === activeState;
      const okText = !q || text.includes(q);
      r.style.display = okState && okText ? "" : "none";
    }
  }

  // Clean up leaked Anki template directives if present.
  stripTypeDirectives(deckList);

  search?.addEventListener("input", apply);
  filters?.addEventListener("click", (e) => {
    const btn = e.target?.closest?.("button[data-state]");
    if (!btn) return;
    activeState = btn.getAttribute("data-state") || "ALL";
    for (const b of Array.from(filters.querySelectorAll("button[data-state]"))) {
      b.classList.toggle("active", b === btn);
    }
    apply();
  });
</script>

